name: Deploy AlphaVox

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        type: choice
        options:
          - staging
          - production
        default: 'staging'
        required: true
      method:
        description: 'Deployment method'
        type: choice
        options:
          - eb
          - cloudformation
          - ecs
        default: 'eb'
        required: true
      subnet_ids:
        description: 'Comma separated list of subnet IDs for ECS'
        required: false
      security_group_ids:
        description: 'Comma separated list of security group IDs for ECS'
        required: false

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run tests
        run: |
          echo "Running tests..."
          # python -m pytest

  build:
    name: Build Application
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Determine environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ENVIRONMENT=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=staging" >> $GITHUB_ENV
          fi
      - name: Build deployment package
        run: |
          echo "Building for environment: ${{ env.ENVIRONMENT }}"
          mkdir -p deploy
          find . -maxdepth 1 -name "*.py" -exec cp -r {} deploy/ \;
          for d in models static templates routes modules .ebextensions; do
            [ -d "$d" ] && cp -r "$d" deploy/
          done
          [ -f "pyproject.toml" ] && cp pyproject.toml deploy/
          cd deploy
          zip -r ../deploy.zip *
      - name: Upload deployment package
        uses: actions/upload-artifact@v4
        with:
          name: deploy-package
          path: deploy.zip

  deploy-eb:
    name: Deploy to Elastic Beanstalk
    needs: build
    if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && (github.event.inputs.method == 'eb'))
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'staging') }}
    steps:
      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: deploy-package
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-west-2' }}
      - name: Install EB CLI
        run: |
          pip install awsebcli
      - name: Deploy to Elastic Beanstalk
        run: |
          ENV_NAME="alphavox-${{ env.ENVIRONMENT }}"
          if ! eb status $ENV_NAME &> /dev/null; then
            echo "Creating new EB environment: $ENV_NAME"
            eb create $ENV_NAME \
              --region ${{ secrets.AWS_REGION || 'us-west-2' }} \
              --platform "Python 3.11" \
              --cname $ENV_NAME \
              --timeout 20
          else
            echo "Deploying to existing environment: $ENV_NAME"
            eb deploy $ENV_NAME \
              --region ${{ secrets.AWS_REGION || 'us-west-2' }} \
              --timeout 20
          fi

  deploy-cloudformation:
    name: Deploy with CloudFormation
    needs: build
    if: github.event_name == 'workflow_dispatch' && (github.event.inputs.method == 'cloudformation')
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-west-2' }}
      - name: Package CloudFormation template
        run: |
          aws cloudformation package \
            --template-file cloudformation/alphavox-infrastructure.yml \
            --s3-bucket alphavox-deployments \
            --output-template-file packaged-template.yml
      - name: Deploy CloudFormation stack
        run: |
          STACK_NAME="alphavox-${{ github.event.inputs.environment }}"
          if aws cloudformation describe-stacks --stack-name $STACK_NAME &> /dev/null; then
            echo "Updating existing CloudFormation stack: $STACK_NAME"
            aws cloudformation update-stack \
              --stack-name $STACK_NAME \
              --template-body file://packaged-template.yml \
              --capabilities CAPABILITY_IAM
          else
            echo "Creating new CloudFormation stack: $STACK_NAME"
            aws cloudformation create-stack \
              --stack-name $STACK_NAME \
              --template-body file://packaged-template.yml \
              --capabilities CAPABILITY_IAM
          fi

  deploy-ecs:
    name: Deploy to ECS
    needs: build
    if: github.event_name == 'workflow_dispatch' && (github.event.inputs.method == 'ecs')
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-west-2' }}
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: alphavox
          IMAGE_TAG: ${{ github.sha }}
        run: |
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY || \
            aws ecr create-repository --repository-name $ECR_REPOSITORY
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
      - name: Update ECS service
        env:
          SUBNET_IDS: ${{ github.event.inputs.subnet_ids || 'subnet-12345,subnet-67890' }}
          SECURITY_GROUP_IDS: ${{ github.event.inputs.security_group_ids || 'sg-12345' }}
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
          CLUSTER_NAME="alphavox-${{ github.event.inputs.environment }}"
          SERVICE_NAME="alphavox-service"
          if [ ! -f .aws/ecs-task-definition.json ]; then
            echo "Task definition not found!"
            exit 1
          fi
          sed -e "s|ACCOUNT_ID|$AWS_ACCOUNT_ID|g" \
              -e "s|REGION|${{ secrets.AWS_REGION || 'us-west-2' }}|g" \
              -e "s|IMAGE_TAG|${{ github.sha }}|g" \
              .aws/ecs-task-definition.json > updated-task-def.json
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://updated-task-def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          aws ecs describe-clusters --clusters $CLUSTER_NAME --query 'clusters[0].status' --output text || \
            aws ecs create-cluster --cluster-name $CLUSTER_NAME
          if aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME --query 'services[0].status' --output text &> /dev/null; then
            echo "Updating existing ECS service"
            aws ecs update-service \
              --cluster $CLUSTER_NAME \
              --service $SERVICE_NAME \
              --task-definition $TASK_DEF_ARN \
              --force-new-deployment
          else
            echo "Creating new ECS service"
            aws ecs create-service \
              --cluster $CLUSTER_NAME \
              --service-name $SERVICE_NAME \
              --task-definition $TASK_DEF_ARN \
              --desired-count 1 \
              --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[${SUBNET_IDS}],securityGroups=[${SECURITY_GROUP_IDS}],assignPublicIp=ENABLED}"
          fi

  post-deploy:
    name: Post-Deployment Tasks
    needs: [deploy-eb, deploy-cloudformation, deploy-ecs]
    if: always() && (needs.deploy-eb.result == 'success' || needs.deploy-cloudformation.result == 'success' || needs.deploy-ecs.result == 'success')
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-west-2' }}
      - name: Determine environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ENVIRONMENT=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=staging" >> $GITHUB_ENV
          fi
      - name: Run database migrations
        run: |
          echo "Running database migrations..."
          # Add migration commands here
      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          # Add verification commands here
      - name: Send notification
        if: always()
        run: |
          DEPLOY_RESULT="${{ job.status }}"
          ENVIRONMENT="${{ env.ENVIRONMENT }}"
          echo "Deployment to $ENVIRONMENT completed with status: $DEPLOY_RESULT"
          # Add notification logic here (e.g., Slack, email)
