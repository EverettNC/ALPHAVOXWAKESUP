from datetime import datetime
from app import db

# Define SQLite/PostgreSQL models for the application

class User(db.Model):
    """User model for storing user details"""
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Relationships
    interactions = db.relationship('UserInteraction', backref='user', lazy='dynamic')
    preferences = db.relationship('UserPreference', backref='user', lazy='dynamic')
    
    def __repr__(self):
        return f'<User {self.name}>'


class UserInteraction(db.Model):
    """Model for storing user interaction history"""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    text = db.Column(db.String(512), nullable=True)
    intent = db.Column(db.String(64), nullable=True)
    confidence = db.Column(db.Float, nullable=True)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    
    def __repr__(self):
        return f'<UserInteraction {self.intent} ({self.confidence:.2f})>'


class UserPreference(db.Model):
    """Model for storing user preferences for the adaptive profile system"""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    type = db.Column(db.String(64), nullable=False)
    value = db.Column(db.String(256), nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    source = db.Column(db.String(64), default='manual')  # 'manual', 'learned', 'system'
    confidence = db.Column(db.Float, default=1.0)  # Confidence in this preference
    
    __table_args__ = (
        db.UniqueConstraint('user_id', 'type', name='_user_preference_type_uc'),
    )
    
    def __repr__(self):
        return f'<UserPreference {self.type}: {self.value}>'
    
    @classmethod
    def get_user_profile(cls, user_id):
        """Get all active preferences for a user as a profile dictionary"""
        preferences = cls.query.filter_by(user_id=user_id, is_active=True).all()
        profile = {}
        
        for pref in preferences:
            # Convert values to appropriate types when possible
            try:
                if pref.value.lower() in ('true', 'false'):
                    # Boolean conversion
                    profile[pref.type] = pref.value.lower() == 'true'
                elif pref.value.replace('.', '', 1).isdigit():
                    # Numeric conversion (float)
                    profile[pref.type] = float(pref.value)
                else:
                    # String value
                    profile[pref.type] = pref.value
            except:
                # If any conversion fails, use the raw value
                profile[pref.type] = pref.value
                
        return profile
    
    @classmethod
    def set_preference(cls, user_id, pref_type, value, source='manual'):
        """Set or update a user preference"""
        # Find existing preference
        pref = cls.query.filter_by(user_id=user_id, type=pref_type).first()
        
        if pref:
            # Update existing
            pref.value = str(value)
            pref.source = source
            pref.is_active = True
            pref.updated_at = datetime.utcnow()
        else:
            # Create new
            pref = cls(
                user_id=user_id,
                type=pref_type,
                value=str(value),
                source=source
            )
            db.session.add(pref)
            
        db.session.commit()
        return pref


class CaregiverNote(db.Model):
    """Model for storing caregiver notes and observations"""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    author = db.Column(db.String(128), nullable=False)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    tags = db.Column(db.String(256), nullable=True)  # Comma-separated tags
    
    user = db.relationship('User', backref=db.backref('caregiver_notes', lazy='dynamic'))
    
    def __repr__(self):
        return f'<CaregiverNote {self.id}: {self.content[:20]}...>'
    
    def get_tags_list(self):
        """Return tags as a list"""
        if not self.tags:
            return []
        return [tag.strip() for tag in self.tags.split(',')]
    
    @classmethod
    def add_note(cls, user_id, author, content, tags=None):
        """Add a new caregiver note"""
        tags_str = ','.join(tags) if tags else None
        
        note = cls(
            user_id=user_id,
            author=author,
            content=content,
            tags=tags_str
        )
        
        db.session.add(note)
        db.session.commit()
        return note


class CommunicationProfile(db.Model):
    """Model for storing user's communication profile"""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    primary_mode = db.Column(db.String(64), nullable=False)  # 'gesture', 'symbol', 'text', etc.
    secondary_mode = db.Column(db.String(64), nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    user = db.relationship('User', backref=db.backref('communication_profiles', lazy='dynamic'))
    
    def __repr__(self):
        return f'<CommunicationProfile {self.primary_mode}/{self.secondary_mode}>'
    
    @classmethod
    def get_latest_profile(cls, user_id):
        """Get the most recent communication profile for a user"""
        return cls.query.filter_by(user_id=user_id).order_by(cls.updated_at.desc()).first()
    
    @classmethod
    def update_profile(cls, user_id, primary_mode, secondary_mode=None):
        """Update a user's communication profile"""
        profile = cls.get_latest_profile(user_id)
        
        if profile:
            # Update existing profile
            profile.primary_mode = primary_mode
            profile.secondary_mode = secondary_mode
            profile.updated_at = datetime.utcnow()
        else:
            # Create new profile
            profile = cls(
                user_id=user_id,
                primary_mode=primary_mode,
                secondary_mode=secondary_mode
            )
            db.session.add(profile)
            
        db.session.commit()
        return profile


class SystemSuggestion(db.Model):
    """Model for storing AI system suggestions for users"""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    title = db.Column(db.String(128), nullable=False)
    description = db.Column(db.Text, nullable=False)
    suggestion_type = db.Column(db.String(64), nullable=False)  # 'feature', 'setting', 'communication'
    confidence = db.Column(db.Float, nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    is_accepted = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    user = db.relationship('User', backref=db.backref('system_suggestions', lazy='dynamic'))
    
    def __repr__(self):
        return f'<SystemSuggestion {self.id}: {self.title}>'
    
    @classmethod
    def get_active_suggestions(cls, user_id):
        """Get all active suggestions for a user"""
        return cls.query.filter_by(user_id=user_id, is_active=True).order_by(cls.confidence.desc()).all()
    
    @classmethod
    def add_suggestion(cls, user_id, title, description, suggestion_type, confidence):
        """Add a new system suggestion"""
        suggestion = cls(
            user_id=user_id,
            title=title,
            description=description,
            suggestion_type=suggestion_type,
            confidence=confidence
        )
        
        db.session.add(suggestion)
        db.session.commit()
        return suggestion
    
    @classmethod
    def accept_suggestion(cls, suggestion_id):
        """Mark a suggestion as accepted"""
        suggestion = cls.query.get(suggestion_id)
        if suggestion:
            suggestion.is_accepted = True
            db.session.commit()
        return suggestion
    
    @classmethod
    def dismiss_suggestion(cls, suggestion_id):
        """Mark a suggestion as inactive"""
        suggestion = cls.query.get(suggestion_id)
        if suggestion:
            suggestion.is_active = False
            db.session.commit()
        return suggestion